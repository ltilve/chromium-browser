<!DOCTYPE html>
<!--
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/statistics.html">
<link rel="import" href="/tracing/extras/chrome/chrome_process_helper.html">
<link rel="import" href="/tracing/extras/rail/rail_interaction_record.html">

<script>
'use strict';

/**
 * @fileoverview The Animation phase of RAIL.
 */
tr.exportTo('tr.e.rail', function() {
  // The computeNormalizedPain regions are delineated at these FPS values.
  var PAIN_FPS_REGIONS = [60, 40, 30, 10];

  // A frame is long if it starts more than this much time after the previous
  // frame.
  var LONG_FRAME_MS = 50;

  // The computeNormalizedPain regions are delineated at these relative
  // discrepancy values.
  var PAIN_JANK_REGIONS = [0.05, 0.1, 0.2, 0.3];

  function AnimationInteractionRecord(start, duration) {
    tr.e.rail.RAILInteractionRecord.call(
        this, 'Animation', 'rail_animate',
        start, duration);
    this.frameEvents_ = undefined;
  }

  AnimationInteractionRecord.prototype = {
    __proto__: tr.e.rail.RAILInteractionRecord.prototype,

    get frameEvents() {
      if (this.frameEvents_)
        return this.frameEvents_;

      this.frameEvents_ = new tr.model.EventSet();

      this.associatedEvents.forEach(function(event) {
        if (event.title === tr.e.audits.IMPL_RENDERING_STATS)
          this.frameEvents_.push(event);
      }, this);

      return this.frameEvents_;
    },

    get normalizedUserPain() {
      return tr.e.rail.weightedAverage2(
          this.normalizedJankPain, this.normalizedFPSPain);
    },

    get normalizedFPSPain() {
      var durationSeconds = this.duration / 1000;
      var avgFps = this.frameEvents.length / durationSeconds;
      var avgSpf = 1 / avgFps;
      return tr.e.rail.computeNormalizedPain(avgSpf, {
        minValueExponential: 1 / PAIN_FPS_REGIONS[0],
        minValueLinear: 1 / PAIN_FPS_REGIONS[1],
        minValueLogarithmic: 1 / PAIN_FPS_REGIONS[2],
        maxValue: 1 / PAIN_FPS_REGIONS[3]
      });
    },

    get normalizedJankPain() {
      var frameTimestamps = this.frameEvents.toArray().map(function(event) {
        return event.start;
      });
      var absolute = false;
      var discrepancy = tr.b.Statistics.timestampsDiscrepancy(
          frameTimestamps, absolute);
      return tr.e.rail.computeNormalizedPain(discrepancy, {
        minValueExponential: PAIN_JANK_REGIONS[0],
        minValueLinear: PAIN_JANK_REGIONS[1],
        minValueLogarithmic: PAIN_JANK_REGIONS[2],
        maxValue: PAIN_JANK_REGIONS[3]
      });
    }
  };

  return {
    AnimationInteractionRecord: AnimationInteractionRecord
  };
});
</script>
